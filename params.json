{"name":"Spring-JDBC-ROMA","tagline":"Spring JDBC extension for object mapping supported rowmapper","body":"## **What is Spring-JDBC-ROMA?**\r\n\r\n**Spring-JDBC-ROMA** is a rowmapper extension for **Spring-JDBC module**. \r\nThere is already a rowmapper named **\"org.springframework.jdbc.core.BeanPropertyRowMapper\"** for binding \r\nresultset attributes to object. But it is reflection based and can cause performance problems as Spring developers said.\r\nHowever **Spring-JDBC-ROMA** is not reflection based and it is byte code generation (with **CGLib** and **Javassist**) \r\nbased rowmapper. It generates rowmapper on the fly like implementing as manual so it has no performance overhead. \r\nIt also supports object relations as lazy and eager. There are other lots of interesting features and \r\nthese features can be customized with developer's extended classes. \r\n\r\n\r\n\r\n## **What features does Spring-JDBC-ROMA have?**\r\n\r\n* All primitive types, enums, dates, collections, blob, clob and complex objects are supported.  \r\n\r\n* Lazy or eager field accessing is supported.   \r\n\r\n* Writing your custom field based **RowMapperFieldGenerator** implementations is supported.   \r\n\r\n* Writing your custom class (or type) based **RowMapperFieldGeneratorFactory** implementations is supported. \r\n  \r\n* Writing field access definitions as compilable Java code in annotation or configuration file (XML file, properties file, ...) is supported.    \r\n\r\n\r\n\r\n## **Install**\r\n\r\nIn your **pom.xml**, you must add repository and dependency for Spring-JDBC-ROMA. \r\nYou can change **spring.jdbc.roma.version** to any existing **spring-jdbc-roma** library version.\r\n\r\n~~~~~ xml\r\n...\r\n<properties>\r\n    ...\r\n    <spring.jdbc.roma.version>1.0.0-RELEASE</spring.jdbc.roma.version>\r\n    ...\r\n</properties>\r\n...\r\n<dependencies>\r\n    ...\r\n\t<dependency>\r\n\t\t<groupId>org.springframework</groupId>\r\n\t\t<artifactId>spring-jdbc-roma</artifactId>\r\n\t\t<version>${spring.jdbc.roma.version}</version>\r\n\t</dependency>\r\n\t...\r\n</dependencies>\r\n...\r\n<repositories>\r\n\t...\r\n\t<repository>\r\n\t\t<id>serkanozal-maven-repository</id>\r\n\t\t<url>https://github.com/serkan-ozal/maven-repository/raw/master/</url>\r\n\t</repository>\r\n\t...\r\n</repositories>\r\n...\r\n~~~~~\r\n\r\nAnd finally, in your **Spring context xml** file add following configuration to make your Spring context automatically aware of Spring-JDBC-ROMA.\r\n\r\n~~~~~ xml\r\n...\r\n<import resource=\"classpath*:roma-context.xml\"/>\r\n...\r\n~~~~~\r\n\r\n\r\n\r\n## **Spring-JDBC-ROMA with a simple example**\r\n  \r\nHere is **User** class:  \r\n\r\n~~~~~ java\r\npublic class User {\r\n\r\n    @RowMapperField(columnName = \"id\")\r\n    private Long id;\r\n    @RowMapperField(columnName = \"username\")\r\n    private String username;\r\n    @RowMapperField(columnName = \"password\")\r\n    private String password;\r\n    @RowMapperField(columnName = \"firstname\")\r\n    private String firstname;\r\n    @RowMapperField(columnName = \"lastname\")\r\n    private String lastname;\r\n    @RowMapperField(columnName = \"enabled\")\r\n    private boolean enabled = true;\r\n    @RowMapperField(columnName = \"gender\")\r\n    private Gender gender;\r\n    @RowMapperObjectField(\r\n        provideViaSpringProvider = \r\n            @RowMapperSpringProvider(\r\n                provideCode = \"@{roleDAO}.getUserRoleList(${id})\"),\r\n        lazy = true)\r\n    private List<Role> roles = new ArrayList<Role>();\r\n    \r\n    ...\r\n    \r\n} \r\n~~~~~\r\n\r\nHere is **Role** class:    \r\n\r\n~~~~~ java\r\npublic class Role {\r\n\r\n    @RowMapperField(columnName = \"id\")\r\n    private Long id;\r\n    @RowMapperField(columnName = \"name\")\r\n    private String name;\r\n    @RowMapperObjectField(\r\n        provideViaSpringProvider = \r\n            @RowMapperSpringProvider(\r\n                provideCode = \"@{permissionDAO}.getRolePermissionList(${id})\"),\r\n        lazy = true)\r\n    private List<Permission> permissions = new ArrayList<Permission>();\r\n\r\n    ...\r\n    \r\n}\r\n~~~~~\r\n\t\r\nYou can get **User** entity rowmapper as follows:\r\n\r\n~~~~~ java\r\n@Autowired\r\nRowMapperService rowMapperService;\r\n    \r\n...\r\n\r\nRowMapper<User> userRowMapper = rowMapperService.getRowMapper(User.class);\r\n~~~~~\r\n\r\nIn this example, we can get related **Role** entites of **User** entity with **\"@RowMapperObjectField\"** annotion automatically. \r\nWe use **\"@RowMapperObjectField\"** annotation for accessing related **Role** entites of **User** entity with **id** attribute of User. \r\nWe have **\"lazy=true\"** configuration, since **roles** field are initialized while we are accessing it first time. \r\nIf we don't access it, it will not be set. \r\n\r\nIn addition, we can define **User** entity with compilable pure Java code as follows:\r\n \r\n~~~~~ java \r\npublic class User {\r\n\r\n    ...\r\n    \r\n    @RowMapperObjectField(\r\n        provideViaImplementationProvider = \r\n            @RowMapperImplementationProvider(\r\n                provideCode = \"RoleDAO.getUserRoleListAsStaticMethod(${id})\", \r\n                usedClasses = {RoleDAO.class}), \r\n        lazy = true)\r\n    private List<Role> roles = new ArrayList<Role>();\r\n    \r\n    ...\r\n    \r\n} \r\n~~~~~\r\n\r\n\r\nAlso, we can user our custom data provider classes these implement **\"RowMapperObjectFieldDataProvider\"** interface with its **\"public Object provideData(T ownerObj)\"** method. Here is sample usage:\r\n\r\n~~~~~ java   \r\npublic class User {\r\n\r\n    ...\r\n    \r\n    @RowMapperObjectField(\r\n        provideViaCustomProvider = \r\n            @RowMapperCustomProvider(\r\n                dataProvider = MyCustomDataProvider.class), \r\n        lazy = true)\r\n    private List<Role> roles = new ArrayList<Role>();\r\n    \r\n    ...\r\n    \r\n} \r\n~~~~~\r\n\r\nYou can find all demo codes (including these samples above) at [https://github.com/serkan-ozal/spring-jdbc-roma-demo](https://github.com/serkan-ozal/spring-jdbc-roma-demo)\r\n \r\n \r\n \r\n## **Roadmap**\r\n\r\n* SQL based provider will be supported for getting relations with pure SQL queries by specifying datasource as follows:\r\n    \r\n~~~~~ java      \r\npublic class User {\r\n\r\n    ...\r\n\r\n    @RowMapperObjectField(\r\n        provideViaSqlProvider = \r\n            @RowMapperSqlProvider(\r\n                sql = \r\n                    \"SELECT r.* FROM ROLE r WHERE r.ID IN \" +\r\n                    \"(\" +\r\n                        \"SELECT ur.ROLE_ID FROM user_role ur WHERE ur.USER_ID = ${id}\" +\r\n                    \") ORDER BY r.name\",\r\n                dataSource = \"MyDataSource\"),\r\n        lazy = true)\r\n    private List<Role> roles = new ArrayList<Role>();\r\n\r\n    ...\r\n\r\n}\r\n~~~~~\r\n\r\n* Field based formatters will be supported for formating field from raw value by impelenting custom formatter classes from **\"RowMapperFieldGeneratorFormatter<T>\"** interface and overriding **\"public T format(T value)\"** method. Here is sample usage:\r\n\r\n~~~~~ java \r\npublic class User {\r\n\r\n\t...\r\n\r\n\t@RowMapperField(\r\n\t\tcolumnName = \"surname\", \r\n\t\tfieldFormatters = {MyTrimFormatter.class, MyUpperCaseFormatter.class})\r\n    private String surname;\r\n\r\n    ...\r\n\r\n}\r\n~~~~~\r\n","google":"UA-40652716-1","note":"Don't delete this file! It's used internally to help with page regeneration."}